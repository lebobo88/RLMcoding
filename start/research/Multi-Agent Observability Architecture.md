Multi-Agent Observability Architecture

1. Core Directive: The "One-Way Data Stream"You are to implement a unidirectional observability pipeline. Data flows strictly from Agents $\rightarrow$ Server $\rightarrow$ Client.Source: Claude Code instances (Agents).Transport: HTTP POST (to Server) & WebSockets (to Client).Persistence: SQLite.Visualization: Real-time Frontend (Vue.js).

2. The Agentic Layer (Source)Location: claude/hooks/ directory within the target codebase.Mechanism: Hooks execute a Python script (using uv for single-file isolation) to emit events.A. Hook ConfigurationImplement the following lifecycle hooks to capture the full agent narrative:pre-tool-use: Fires before an action is taken.post-tool-use: Fires after an action completes (captures output).sub-agent-complete: Fires when a delegated sub-agent finishes.stop: Fires when the session ends or user input is requested. [10:13]B. The send_event ProtocolScript: Create a unified send_event function called by all hooks.Identity Hashing: Generate a unique color/hash based on the App Name + Session ID to visually distinguish agents in the UI.Intelligence Layer (Pre-computation):Instruction: Do not send raw JSON payloads alone.Summarization: Inside the hook, call a small, fast model (e.g., Haiku) to generate a 1-sentence human-readable summary of the event (e.g., "Agent wrote HTML file for clinical dashboard"). [12:47]Benefit: Keeps the observability feed readable at a glance without expanding JSON blobs.

3. The Server Layer (Ingestion & Storage)Runtime: Bun (for speed and simplicity).Database: SQLite (SQL-like persistence for portability).Endpoints:POST /events: Receives payload from Agents.WS /: WebSocket connection for broadcasting to Clients.Data Handling LogicReceive the event via HTTP.Persist the event immediately to SQLite.Broadcast the event immediately via WebSocket to all connected clients.No Processing: The server should strictly be a pass-through. Summarization happens at the edge (in the Agent hook). [08:01]

4. The Client Layer (Visualization)Framework: Vue.js (or any lightweight frontend).Component: "Activity Pulse" Feed.Features:Live Stream: Append new events via WebSocket.Filtering: Allow filtering by Session ID, App Name, or Event Type (e.g., only show stop events to see where human input is needed).Transcript Dump: On a stop event, allow the UI to display/copy the full chat transcript for debugging context. [10:31]

5. Scale & Usage PrinciplesDecoupled Architecture: The observability server runs independently. Agents can run on the local machine, remote servers, or inside containers; they simply need the URL of the observability server.Purpose:Monitor: Watch 5-10 agents working in parallel.Intervene: Watch for "Agent needs input" events to unblock specific workers.Trace: Use the Session ID to trace the logic failure of a specific agent after the fact.

6. Summary Checklist for ImplementationInstall Hooks: Ensure claude/hooks contains the send_event logic.Enable Summaries: Verify the "fast model" is summarizing tool outputs before transmission.Start Server: Boot the Bun server + SQLite DB.Connect Client: Open the Dashboard and watch for the "Pulse."